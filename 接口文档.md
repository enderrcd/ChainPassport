
# 开头先提醒一下
前端那个公司的登陆页面地址写成http://localhost:8080/oauth2/register/gitee





# 用户登录接口文档

## 接口说明
用户通过用户名和密码进行登录认证，认证成功后返回JWT令牌。

## 基本信息
- **接口地址**: POST /login
- **接口描述**: 用户登录认证接口
- **权限要求**: 无需认证

## 请求参数
| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| userName | string | 是 | 用户名 |
| password | string | 是 | 密码 |
| nickName | string | 否 | 用户昵称 |
| status | string | 否 | 账号状态 |
| email | string | 否 | 邮箱地址 |
| phonenumber | string | 否 | 手机号码 |
| sex | string | 否 | 性别 |
| avatar | string | 否 | 头像URL |
| userType | string | 否 | 用户类型 |
| delFlag | integer | 否 | 删除标志 |

## 请求示例

json
    
    {
    
     "userName": "admin",
     "password": "123456" 
     
     }

## 响应参数
| 参数名 | 类型 | 说明 |
|--------|------|------|
| code | integer | 响应状态码，200表示成功 |
| msg | string | 响应消息 |
| data | string | JWT认证令牌 |

## 响应示例
json

    {
        "code": 200, 
        "msg": "操作成功",
        "data": "eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYzA2YzQ0ZC04YzQ0LTQyYTctYjBhNy00ZjQ0YzQ0ZDgiLCJzdWIiOiJ7XCJ1c2VySWRcIjpcIjFcIn0iLCJpYXQiOjE2MzQ1NjY4MzQsImV4cCI6MTYzNDU3MDQzNH0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" }

## 处理流程
1. 接收客户端发送的用户名和密码
2. 使用Spring Security的`AuthenticationManager`进行身份认证
3. 认证成功后，生成JWT令牌
4. 将用户信息存储到Redis缓存中
5. 返回JWT令牌给客户端


# 注意事项
这个jwt你们前端要保存下来，而且设置过期时间为30分钟，这段时间用户每次访问网站的时候都要直接跳过登陆界面，直接访问之后的主页面等，切记不要再让他们看到登陆界面了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！   补充一下：不要忘了放在请求头里面哦


# 用户登出接口文档

## 接口说明
用户退出登录，清除Redis中存储的用户认证信息。

## 基本信息
- **接口地址**: POST /logout/user
- **接口描述**: 用户登出接口，用于清除用户会话
- **权限要求**: 需要有效的认证令牌

## 请求头
| 参数名 | 类型 | 必填 | 位置 | 说明 |
|--------|------|------|------|------|
| authentication | string | 是 | Request Header | JWT认证令牌 |
## 响应参数
| 参数名 | 类型 | 说明 |
|--------|------|------|
| code | integer | 响应状态码，200表示成功 |
| msg | string | 响应消息 |
| data | object | 响应数据 |

## 响应示例
json { "code": 200, "msg": "操作成功", "data": null }

## 处理流程
1. 从请求头中获取JWT令牌
2. 调用UserService的logout方法
3. 在UserService中：
   - 从SecurityContextHolder获取当前认证信息
   - 获取用户ID
   - 从Redis中删除该用户的登录信息
4. 返回操作成功响应




# Gitee OAuth2 配置接口文档

## 接口说明
获取Gitee OAuth2认证所需配置信息，用于跳转到Gitee授权页面。

## 基本信息
- **接口地址**: POST /public/login/gitee/config
- **接口描述**: 获取Gitee OAuth2配置信息，用于第三方登录
- **权限要求**: 需要有效的认证令牌（可选）


## 请求头
| 参数名 | 类型 | 必填 | 位置 | 说明 |
|--------|------|------|------|------|
| giteeId | string | 否 | Request Header | 标识用户唯一id |

说明:这个giteeId是当前端保存的jwt过期的时候才有用的，jwt过期而giteeId没有过期的时候，这时候你们把giteeId传过来可以让用户跳过授权重新生成新的jwt令牌。。如果都过期的话，请求头里面就传一个值为null的giteeId就行，让用户重新认证授权

## 响应参数
| 参数名 | 类型 | 说明 |
|--------|------|------|
| code | integer | 响应状态码，200表示成功 |
| msg | string | 响应消息 |
| data | object | OAuth2配置信息 |
| data.client_id | string | Gitee应用的客户端ID |
| data.redirect_uri | string | 回调地址 |
| data.response_type | string | 响应类型，通常为code |
| data.scope | string | 请求权限范围 |

## 响应示例
json

    { 
        "code": 200, 
        "msg": "操作成功",
         "data": 
         { 
            "client_id": "your_client_id",
             "redirect_uri": "http://localhost:8080/callback", "response_type": "code", 
             "scope": "user_info projects" (可有可无)
             } 
    }
# 后续处理
将这些数据编码后当作请求参数拼接在登陆界面网址的后面，然后以get请求跳转到官方的授权页面。之后我后端经过一系列处理会自动帮你跳转到主页面，就设置成http//localhost:8080/main吧，然后这个网址后面我会拼接有一个叫token的请求参数，你把它取出来放在请求头里面就行。。然后也是记得之后自动跳过登陆界面并设置过期时间。对了，还有一个叫giteeId的请求参数，这个也保存在请求头里面，过期时长弄成1个小时，我之后要弄一个跳过授权的功能，必须需要这个东西






# ZKP身份认证

# 用户注册接口文档

## 接口说明
用户注册接口，生成Ed25519密钥对并初始化零知识证明(ZKP)认证流程。

## 基本信息
- **接口地址**: POST /public/register
- **接口描述**: 生成用户密钥对，创建JWT令牌，并初始化ZKP认证流程
- **权限要求**: 无需认证

## 请求参数
无请求参数

## 请求示例
bash curl -X POST "http://localhost:8080/public/register"
## 响应参数
| 参数名 | 类型 | 说明 |
|--------|------|------|
| code | integer | 响应状态码，200表示成功 |
| msg | string | 响应消息 |
| data | object | HttpSession对象 |

## 响应示例
json { "code": 200, "msg": "操作成功", "data": "org.apache.catalina.session.StandardSessionFacade@xxxxx" }
## 处理流程
1. 使用Ed25519算法生成密钥对（公钥和私钥）
2. 生成唯一的用户UUID作为用户标识
3. 创建JWT令牌，包含用户ID信息
4. 获取HttpSession并将JWT存储在session属性中（key为"loginJwt"）
5. 将私钥存储到Redis缓存中，key为"loginPrivate:{jwt}"（现实情况下两个页面的redis肯定不是一台的，迫于条件限制，我们实际上无法测试这个功能，只能理论上实现）
6. 向认证服务发送请求，传递公钥和JWT令牌
   - 请求地址: http://localhost:8080/public/login/ZKP
   - 参数: PublicSecret（公钥）, jwt（JWT令牌）
7. 等待认证服务响应确认
8. 返回包含session信息的成功响应


# 零知识证明认证按钮接口文档

## 接口说明
处理零知识证明(ZKP)认证流程，验证用户身份的真实性。（公司页面，需要按钮点击

## 基本信息
- **接口地址**: POST /public/login/button
- **接口描述**: 执行零知识证明认证，验证用户是否拥有正确的私钥
- **权限要求**: 需要预先通过A区认证并获得JWT令牌

## 请求参数
记得将session对象传过来，好像不用特意传，这里应该会自动接收的
无请求参数

## 请求示例
bash curl -X POST "http://localhost:8080/public/login/button"
## 响应参数
| 参数名 | 类型 | 说明 |
|--------|------|------|
| code | integer | 响应状态码，200表示成功 |
| msg | string | 响应消息 |
| data | string | token |

## 响应示例
json { "code": 200, "msg": "操作成功", "data": token的值 }


## 处理流程
1. 从HttpSession中获取JWT令牌（key为"loginJwt"）
2. 如果JWT为空，返回错误信息"请先去A认证"
3. 创建HTTP客户端，向http://localhost:8080/login/ZKP发送POST请求
4. 请求中携带JWT令牌作为认证头
5. 接收响应数据，获取签名信息
6. 从Redis中获取之前存储的公钥（key为"loginPublic:{jwt}"）
7. 使用Ed25519算法验证签名的有效性
   - 使用JWT作为消息
   - 使用解码后的签名数据
   - 使用从Redis获取的公钥
8. 如果验证成功，返回成功信息"认证成功，确实是A区的认证"
9. 如果验证失败，返回错误信息"认证失败，请重新认证"

说一下跳转流程，首先最开始用户先到公司界面，里面有一个可以跳转到身份验证界面的按钮之类的东西，点击之后跳转，在那个页面中授权成功后在自动跳转回登陆界面，然后开始验证，通过的话就跳转到主页面，不通过的话就重试/////响应的token处理方法跟上文一模一样